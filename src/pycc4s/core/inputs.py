"""Inputs for CC4S."""
import json
from importlib import import_module
from typing import List

import yaml  # type: ignore
from pydantic import BaseModel
from pymatgen.io.core import InputFile

from pycc4s.core.algorithms import BaseAlgo, MyDumper, Object, get_algo


class CC4SIn(InputFile, BaseModel):
    """Class used to represent the input for CC4S."""

    algos: List[BaseAlgo]

    @classmethod
    def from_string(cls, string):
        """Read CC4SIn from string."""
        dd = yaml.safe_load(string)
        algos = [get_algo(algo_d) for algo_d in dd]
        return cls(algos=algos)

    @classmethod
    def from_file(cls, path="cc4s.in"):
        """Construct CC4SIn object from file."""
        return super().from_file(path)

    def get_string(self) -> str:
        """Get the string representation of the input."""
        return self.to_string(fmt="yaml")

    def to_string(self, fmt=None):
        """Get a formatted string representation of the CC4SIn object.

        For yaml format, a special Dumper is used to match the way cc4s
        examples are provided.
        """
        fmt = fmt or "yaml"
        if fmt == "yaml":
            return yaml.dump(
                self.dict(),
                Dumper=MyDumper,
                default_flow_style=False,
                sort_keys=False,
            )
        else:
            json.dumps(self.as_dict())

    def to_file(self, fname="cc4s.in", fmt=None):
        """Write CC4SIn to file."""
        if fmt is None and fname == "cc4s.in":
            fmt = "yaml"
        with open(fname, "w") as f:
            f.write(self.to_string(fmt=fmt))

    def validate(self):
        """Validate the input.

        This method checks that the input objects of a given algorithm have
        been read or generated by a previous algorithm.
        """
        objects = []
        for ialgo, algo in enumerate(self.algos):
            for _input_name, input_value in algo.input._iter():
                if isinstance(input_value, Object):
                    if input_value not in objects:
                        raise ValueError(
                            f'"{input_value.__class__.__name__}" object with name '
                            f'"{input_value.object_name()}" is needed as input for '
                            f'"{algo.name}" algorithm (#{ialgo+1}).'
                        )
            for _output_name, output_value in algo.output._iter():
                if isinstance(output_value, Object):
                    objects.append(output_value)

    def dict(self, *args, **kwargs):
        """Override pydantic's dict method so that it writes just the list of algos.

        The model contains an algos field but we don't want this field in the
        file that is written in the end. Indeed the CC4S input file is just a
        sequence of algorithms defined one after another.
        """
        dd = super().dict(*args, **kwargs)
        dd = dd["algos"]

        # We don't want to have null in the yaml file (can be misunderstood
        # as an object by cc4s)
        def stripNone(data):
            if isinstance(data, dict):
                return {
                    k: stripNone(v)
                    for k, v in data.items()
                    if k is not None and v is not None
                }
            return data

        dd = [stripNone(algo_d) for algo_d in dd]
        return dd

    def as_dict(self):
        """Return a dict representation of the CC4SIn object."""
        d = {"@module": self.__class__.__module__, "@class": self.__class__.__name__}

        try:
            parent_module = self.__class__.__module__.split(".", maxsplit=1)[0]
            module_version = import_module(parent_module).__version__  # type: ignore
            d["@version"] = str(module_version)
        except (AttributeError, ImportError):
            d["@version"] = None  # type: ignore

        d["algos"] = [algo.as_dict() for algo in self.algos]
        return d
